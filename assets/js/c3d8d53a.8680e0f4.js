"use strict";(self.webpackChunkmy_learnings=self.webpackChunkmy_learnings||[]).push([[988],{3329:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>h,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"DSA/Tree","title":"Trees","description":"Details about trees.","source":"@site/docs/DSA/Tree.md","sourceDirName":"DSA","slug":"/DSA/Tree","permalink":"/learndocs/DSA/Tree","draft":false,"unlisted":false,"editUrl":"https://github.com/stevenovak123/learndocs/tree/master/docs/DSA/Tree.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Trees","description":"Details about trees."},"sidebar":"tutorialSidebar","previous":{"title":"Stacks and Queues","permalink":"/learndocs/DSA/Stack"},"next":{"title":"Heaps","permalink":"/learndocs/DSA/Heap"}}');var i=n(4848),l=n(8453);const s={sidebar_position:4,title:"Trees",description:"Details about trees."},o=void 0,h={},a=[{value:"Binary Search Tree",id:"binary-search-tree",level:2},{value:"Tree Traversal",id:"tree-traversal",level:2},{value:"Breadth First Search (BFS)",id:"breadth-first-search-bfs",level:3},{value:"Psuedocode BFS",id:"psuedocode-bfs",level:3},{value:"Depth First Search (DFS)",id:"depth-first-search-dfs",level:3},{value:"Psuedocode PreOrder DFS",id:"psuedocode-preorder-dfs",level:3},{value:"Psuedocode PostOrder DFS",id:"psuedocode-postorder-dfs",level:3},{value:"Psuedocode InOrder DFS",id:"psuedocode-inorder-dfs",level:3},{value:"Tree implementation",id:"tree-implementation",level:2}];function d(e){const r={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.p,{children:"Trees are nodes that are in a parent-child relationship."}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Root: it is the top node of a tree."}),"\n",(0,i.jsx)(r.li,{children:"Child: it is a node directly connected to another node when moving away from the root."}),"\n",(0,i.jsx)(r.li,{children:"Parent: The converse of a child."}),"\n",(0,i.jsx)(r.li,{children:"Siblings: group nodes with the same parent."}),"\n",(0,i.jsx)(r.li,{children:"Leaf : A node with no children."}),"\n",(0,i.jsx)(r.li,{children:"Edge : The connection between one node and another."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"There are types of trees."}),"\n",(0,i.jsx)(r.h2,{id:"binary-search-tree",children:"Binary Search Tree"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Every parent node has at the most two children."}),"\n",(0,i.jsx)(r.li,{children:"Every node to the left of the parent node is always less than the parent."}),"\n",(0,i.jsx)(r.li,{children:"Every node to the right of the parent node is always greater than the parent"}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"tree-traversal",children:"Tree Traversal"}),"\n",(0,i.jsx)(r.p,{children:"These are independent of type of trees and can be applied across. There are two types of traversal."}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"BFS."}),"\n",(0,i.jsx)(r.li,{children:"DFS."}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"breadth-first-search-bfs",children:"Breadth First Search (BFS)"}),"\n",(0,i.jsx)(r.p,{children:"BFS is searching across the tree on each level."}),"\n",(0,i.jsx)(r.h3,{id:"psuedocode-bfs",children:"Psuedocode BFS"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Create a queue and a variable to store the values of nodes visited."}),"\n",(0,i.jsx)(r.li,{children:"Place the root node in the queue."}),"\n",(0,i.jsxs)(r.li,{children:["Loop as long as there is anything in the queue.","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Dequeue a node from the queue and push the value of the node into the variable that stores the nodes"}),"\n",(0,i.jsx)(r.li,{children:"If there is a left property on the dequeued node - add it to the queue."}),"\n",(0,i.jsx)(r.li,{children:"if there is a right property on the dequeued node - add it to the queue."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.li,{children:"Return the variable that is storing values."}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"depth-first-search-dfs",children:"Depth First Search (DFS)"}),"\n",(0,i.jsx)(r.p,{children:"DFS is vertically going down and searching."}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["there are 3 ways of DFS","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"PreOrder: Visit the current node, then left subtree, then right subtree."}),"\n",(0,i.jsx)(r.li,{children:"InOrder: Visit the left subtree, then current node, then right subtree."}),"\n",(0,i.jsx)(r.li,{children:"PostOrder: Visit the left subtree, then right subtree, then current node."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"psuedocode-preorder-dfs",children:"Psuedocode PreOrder DFS"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Create a variable to store the values of the node visited."}),"\n",(0,i.jsx)(r.li,{children:"Store the root of the tree in a variable called current."}),"\n",(0,i.jsxs)(r.li,{children:["Write a helper function which accepts a node.","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Push the value of the node to the variable that stores the values."}),"\n",(0,i.jsx)(r.li,{children:"If the node has a left property, call the helper function with the left property on the node."}),"\n",(0,i.jsx)(r.li,{children:"If the node has a right property, call the helper funciton with the right property on the node."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.li,{children:"Invoke the helper function with the current variable."}),"\n",(0,i.jsx)(r.li,{children:"Return the array of values."}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"psuedocode-postorder-dfs",children:"Psuedocode PostOrder DFS"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Create a variable to store the values of the node visited."}),"\n",(0,i.jsx)(r.li,{children:"Store the root of the tree in a variable called current."}),"\n",(0,i.jsxs)(r.li,{children:["Write a helper function which accepts a node.","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"If the node has a left property, call the helper function with the left property on the node."}),"\n",(0,i.jsx)(r.li,{children:"If the node has a right property, call the helper funciton with the right property on the node."}),"\n",(0,i.jsx)(r.li,{children:"Push the value of the node to the variable that stores the values"}),"\n",(0,i.jsx)(r.li,{children:"Invoke the helper function with the current variable."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.li,{children:"Return the array of values."}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"psuedocode-inorder-dfs",children:"Psuedocode InOrder DFS"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Create a variable to store the values of the node visited."}),"\n",(0,i.jsx)(r.li,{children:"Store the root of the tree in a variable called current."}),"\n",(0,i.jsxs)(r.li,{children:["Write a helper function which accepts a node.","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"If the node has a left property, call the helper function with the left property on the node."}),"\n",(0,i.jsx)(r.li,{children:"Push the value of the node to the variable that stores the values"}),"\n",(0,i.jsx)(r.li,{children:"If the node has a right property, call the helper funciton with the right property on the node."}),"\n",(0,i.jsx)(r.li,{children:"Invoke the helper function with the current variable."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.li,{children:"Return the array of values."}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"tree-implementation",children:"Tree implementation"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-js",children:"class Node {\r\n  constructor(value) {\r\n    this.value = value;\r\n    this.left = null;\r\n    this.right = null;\r\n  }\r\n}\r\n\r\nclass BinarySearchTree {\r\n  constructor() {\r\n    this.root = null;\r\n  }\r\n  insert(value) {\r\n    let newNode = new Node(value);\r\n    if (this.root === null) {\r\n      this.root = newNode;\r\n      return this;\r\n    }\r\n    let current = this.root;\r\n    while (true) {\r\n      if (value === current.value) return undefined;\r\n      if (value < current.value) {\r\n        if (current.left === null) {\r\n          current.left = newNode;\r\n          return this;\r\n        }\r\n        current = current.left;\r\n      } else {\r\n        if (current.right === null) {\r\n          current.right = newNode;\r\n          return this;\r\n        }\r\n        current = current.right;\r\n      }\r\n    }\r\n  }\r\n  find(value) {\r\n    if (this.root === null) return false;\r\n    let current = this.root;\r\n    let found = false;\r\n    while (current && !found) {\r\n      if (value < current.value) {\r\n        current = current.left;\r\n      } else if (value > current.value) {\r\n        current = current.right;\r\n      } else {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n  BFS() {\r\n    let node = this.root;\r\n    let data = [];\r\n    let queue = [];\r\n    queue.push(node);\r\n    while (queue.length) {\r\n      node = queue.shift();\r\n      data.push(node.value);\r\n      if (node.left) queue.push(node.left);\r\n      if (node.right) queue.push(node.right);\r\n    }\r\n    return data;\r\n  }\r\n  DFSPreOrder() {\r\n    let data = [];\r\n    let current = this.root;\r\n    function traverse(node) {\r\n      data.push(node.value);\r\n      if (node.left) traverse(node.left);\r\n      if (node.right) traverse(node.right);\r\n    }\r\n    traverse(current);\r\n\r\n    return data;\r\n  }\r\n  DFSPostOrder() {\r\n    let data = [];\r\n    let current = this.root;\r\n    function traverse(node) {\r\n      if (node.left) traverse(node.left);\r\n      if (node.right) traverse(node.right);\r\n      data.push(node.value);\r\n    }\r\n    traverse(current);\r\n\r\n    return data;\r\n  }\r\n  DFSPostOrder() {\r\n    let data = [];\r\n    let current = this.root;\r\n    function traverse(node) {\r\n      if (node.left) traverse(node.left);\r\n      data.push(node.value);\r\n      if (node.right) traverse(node.right);\r\n    }\r\n    traverse(current);\r\n\r\n    return data;\r\n  }\r\n}\n"})})]})}function c(e={}){const{wrapper:r}={...(0,l.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>o});var t=n(6540);const i={},l=t.createContext(i);function s(e){const r=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(l.Provider,{value:r},e.children)}}}]);