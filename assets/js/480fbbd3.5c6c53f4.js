"use strict";(self.webpackChunkmy_learnings=self.webpackChunkmy_learnings||[]).push([[874],{5495:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=s(4848),t=s(8453);const o={sidebar_position:10,Title:"Asynchronous JavaScript",Description:"Information on Asynchronous JavaScript"},a="Asynchronous JavaScript",i={id:"JavaScript/AsyncJS",title:"Asynchronous JavaScript",description:"Asynchronous code is non-blocking and is executed after a task that runs in the background finishes.",source:"@site/docs/JavaScript/AsyncJS.md",sourceDirName:"JavaScript",slug:"/JavaScript/AsyncJS",permalink:"/learndocs/JavaScript/AsyncJS",draft:!1,unlisted:!1,editUrl:"https://github.com/stevenovak123/learndocs/tree/master/docs/JavaScript/AsyncJS.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10,Title:"Asynchronous JavaScript",Description:"Information on Asynchronous JavaScript"},sidebar:"tutorialSidebar",previous:{title:"Numbers and Dates",permalink:"/learndocs/JavaScript/NumbersAndDates"},next:{title:"Introduction to React",permalink:"/learndocs/React/intro"}},l={},c=[{value:"Handling AJAX. (OLD way)",id:"handling-ajax-old-way",level:2},{value:"Promises.",id:"promises",level:2},{value:"Handling Promises",id:"handling-promises",level:3},{value:"Promise Combinators.",id:"promise-combinators",level:3},{value:"Promise.all()",id:"promiseall",level:3},{value:"Promise.race()",id:"promiserace",level:3},{value:"Promise.allSettled()",id:"promiseallsettled",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"asynchronous-javascript",children:"Asynchronous JavaScript"}),"\n",(0,r.jsx)(n.p,{children:"Asynchronous code is non-blocking and is executed after a task that runs in the background finishes.\r\nExecution does not wait for an asynchronous task to finish its work."}),"\n",(0,r.jsx)(n.p,{children:"Often used to make AJAX calls.\r\nAJAX stands for Asynchronous JavaScript and XML.\r\nIt allows to communicate with remote web servers in an asynchronous way."}),"\n",(0,r.jsx)(n.h2,{id:"handling-ajax-old-way",children:"Handling AJAX. (OLD way)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",metastring:"title='AJAX the old way'",children:"const request = new XMLHttpRequest();\r\nrequest.open('GET', 'API_URL');\r\nrequest.send();\r\nrequest.addEventListener('load', function () {\r\n  // this code is executed after the call is done.\r\n  console.log(this.responseText); // Here all the data of the AJAX call would be visible.\r\n\r\n  const data = JSON.parse(this.responseText);\r\n  console.log(data); // Data in JSON format.\r\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"This data would be posted into the html content."}),"\n",(0,r.jsx)(n.h2,{id:"promises",children:"Promises."}),"\n",(0,r.jsx)(n.p,{children:"Promises are an object used as a placeholder for the future result of an asynchronous operation. It used to contain future values (avoid callback nesting/loop). This is an ES6 feature."}),"\n",(0,r.jsx)(n.p,{children:"This is a cleaner way to handle asynchronous code. We use the Fetch API for this."}),"\n",(0,r.jsx)(n.p,{children:"Promises are time sensitive and have multiple stages. We can handle all the different stages through code."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Pending: the async task is executing or is not yet executed."}),"\n",(0,r.jsxs)(n.li,{children:["Settled: It has two sub stages. Fulfilled and Rejected.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fulfilled: It has sucessfully resulted in a value."}),"\n",(0,r.jsx)(n.li,{children:"Rejected: Error has occurred."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"handling-promises",children:"Handling Promises"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JS",metastring:'Title="Handling Promises (Fulfilled)"',children:'const data= function(param){\r\n    fetch("API_URL").then(function(response){\r\n        return response.json(); // this also results in an promise hence a then has to be appended\r\n    }).then(function(resData){\r\n        console.log(resData)\r\n    })\r\n}\r\n\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JS",metastring:'Title="Handling Promises (Rejected)"',children:'const data= function(param){\r\n    fetch("API_URL").then(function(response){\r\n        return response.json();\r\n    }).then(function(resData){\r\n        console.log(resData)\r\n    }).catch(error=> alert(error)) // Throws an alert that error has occurred.\r\n}\r\n\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",metastring:'Title="Building Promises"',children:"function checkNumberAsync(num) {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      if (num > 0) {\r\n        resolve('The number is positive.');\r\n      } else {\r\n        reject('The number is not positive.');\r\n      }\r\n    }, 1000); // 1 second delay\r\n  });\r\n}\r\n// Using the Promise\r\nasync function runChecks() {\r\n  try {\r\n    const message1 = await checkNumberAsync(5);\r\n    console.log('Success:', message1);\r\n\r\n    const message2 = await checkNumberAsync(-3);\r\n    console.log('Success:', message2);\r\n  } catch (error) {\r\n    console.error('Error:', error);\r\n  }\r\n}\r\n\r\nrunChecks();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"promise-combinators",children:"Promise Combinators."}),"\n",(0,r.jsx)(n.p,{children:"Promises can be executed in parallel. This is used when Async code/ network call codes are not interdependent on each other."}),"\n",(0,r.jsxs)(n.p,{children:["The method used is ",(0,r.jsx)(n.code,{children:"Promise.all()"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"promiseall",children:"Promise.all()"}),"\n",(0,r.jsx)(n.p,{children:"Takes and interable of promises as input and returns a single Promise. If one of the Promises fails the whole promise will fail."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"async function fetchData() {\r\n  const data = await Promise.all([\r\n    fetch('API_URL_1'),\r\n    fetch('API_URL_2'),\r\n    fetch('API_URL_3'),\r\n  ]);\r\n  console.log(data);\r\n}\r\n\r\nfetchData();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"promiserace",children:"Promise.race()"}),"\n",(0,r.jsx)(n.p,{children:"The method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"async function run() {\r\n  const fastestResponse = await Promise.race([\r\n    fetch('API_URL_1'),\r\n    fetch('API_URL_2'),\r\n    fetch('API_URL_3'),\r\n  ]);\r\n\r\n  const data = await fastestResponse.json();\r\n  console.log('Fastest response data:', data);\r\n}\r\n\r\nrun(); // \u2190 call the function\n"})}),"\n",(0,r.jsx)(n.h3,{id:"promiseallsettled",children:"Promise.allSettled()"}),"\n",(0,r.jsxs)(n.p,{children:["The method takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when ",(0,r.jsx)(n.strong,{children:"all"})," of the input's promises settle (including when an empty iterable is passed), with an array of objects that describe the outcome of each promise."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'function checkNumberAsync(num) {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      if (num > 0) {\r\n        resolve(`\u2714\ufe0f ${num} is positive.`);\r\n      } else {\r\n        reject(`\u274c ${num} is not positive.`);\r\n      }\r\n    }, Math.random() * 2000); // random delay up to 2s\r\n  });\r\n}\r\n\r\nconst numbers = [5, -3, 0, 7, -1];\r\n\r\nconst promises = numbers.map(checkNumberAsync);\r\n\r\nPromise.allSettled(promises)\r\n  .then((results) => {\r\n    results.forEach((result, index) => {\r\n      if (result.status === "fulfilled") {\r\n        console.log(`Promise ${index + 1} succeeded:`, result.value);\r\n      } else {\r\n        console.error(`Promise ${index + 1} failed:`, result.reason);\r\n      }\r\n    });\r\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var r=s(6540);const t={},o=r.createContext(t);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);