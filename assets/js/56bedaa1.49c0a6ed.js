"use strict";(self.webpackChunkmy_learnings=self.webpackChunkmy_learnings||[]).push([[18],{3795:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"JavaScript/Functions","title":"Functions","description":"A function is simply a chunk of code that can be used over and over again.","source":"@site/docs/JavaScript/Functions.md","sourceDirName":"JavaScript","slug":"/JavaScript/Functions","permalink":"/learndocs/JavaScript/Functions","draft":false,"unlisted":false,"editUrl":"https://github.com/stevenovak123/learndocs/tree/master/docs/JavaScript/Functions.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"Title":"Functions in JS","Description":"Information on Functions in JavaScript"},"sidebar":"tutorialSidebar","previous":{"title":"Strings and Template Literals","permalink":"/learndocs/JavaScript/Strings"},"next":{"title":"Arrays","permalink":"/learndocs/JavaScript/Arrays"}}');var a=r(4848),o=r(8453);const s={sidebar_position:5,Title:"Functions in JS",Description:"Information on Functions in JavaScript"},i="Functions",l={},c=[{value:"Function decalaration",id:"function-decalaration",level:2},{value:"Function Expression",id:"function-expression",level:2},{value:"Arrow Functions",id:"arrow-functions",level:2},{value:"Parameters in Functions",id:"parameters-in-functions",level:2},{value:"Rules of Parameters in Functions",id:"rules-of-parameters-in-functions",level:3},{value:"Default Parameters",id:"default-parameters",level:3},{value:"Passing Arguments: Value vs References",id:"passing-arguments-value-vs-references",level:3},{value:"First Class and Higher Order functions",id:"first-class-and-higher-order-functions",level:2},{value:"Call, Apply and Bind methods",id:"call-apply-and-bind-methods",level:2},{value:"Immediately Invoked Function Expressions (IIFE)",id:"immediately-invoked-function-expressions-iife",level:2},{value:"Closures",id:"closures",level:2}];function u(n){const e={admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"functions",children:"Functions"})}),"\n",(0,a.jsx)(e.p,{children:"A function is simply a chunk of code that can be used over and over again."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'function logger() {\r\n  console.log("My name is steve");\r\n}\r\n// Calling / running /invoking functions\r\nlogger();\n'})}),"\n",(0,a.jsx)(e.p,{children:"The function can be called n number of times."}),"\n",(0,a.jsx)(e.p,{children:"Function can take data and return data. This data can be in any form."}),"\n",(0,a.jsx)(e.h2,{id:"function-decalaration",children:"Function decalaration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function abcd(data) {\r\n  return 2023 - data;\r\n}\r\nconst declaration = abcd(2001);\n"})}),"\n",(0,a.jsx)(e.h2,{id:"function-expression",children:"Function Expression"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"const efgh = function (data) {\r\n  return 2023 - data;\r\n};\r\nconst expression = efgh(2001);\n"})}),"\n",(0,a.jsxs)(e.p,{children:["The difference between declaration and expression is that we can call declarations before they are defined in code. Order of ",(0,a.jsx)(e.code,{children:"const declaration=abcd(2001)"})," should not matter."]}),"\n",(0,a.jsx)(e.h2,{id:"arrow-functions",children:"Arrow Functions"}),"\n",(0,a.jsx)(e.p,{children:"Arrow functions are just a faster way of writing functions. here return happens implicitly. (No need to mention return when its one line of code and one parameter)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"const ijkl = (data) => 2023 - data;\r\nconst arrow = ijkl(2001);\r\nconst yearsUntilRetire = (data) => {\r\n  const age = 2023 - data;\r\n  const retirement = 65 - age;\r\n  return retirement;\r\n};\r\nconsole.log(yearsUntilRetire(2001));\n"})}),"\n",(0,a.jsx)(e.h2,{id:"parameters-in-functions",children:"Parameters in Functions"}),"\n",(0,a.jsx)(e.p,{children:"Functions can be called with arguments and without parameters. There is no binding rule that a function should be called with all its parameters in Javascript."}),"\n",(0,a.jsx)(e.h3,{id:"rules-of-parameters-in-functions",children:"Rules of Parameters in Functions"}),"\n",(0,a.jsx)(e.p,{children:"JavaScript function definitions do not specify data types for parameters.\r\nJavaScript functions do not perform type checking on the passed arguments.\r\nJavaScript functions do not check the number of arguments received."}),"\n",(0,a.jsx)(e.h3,{id:"default-parameters",children:"Default Parameters"}),"\n",(0,a.jsx)(e.p,{children:"If a function is called with missing arguments (less than declared), the missing values are set to undefined.\r\nSometimes this is acceptable, but sometimes it is better to assign a default value to the parameter. ES6 allows functions to have default values as well"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",metastring:'title="parameter example"',children:'function add(a, b) {\r\n  return a + b;\r\n}\r\n\r\n// Example usage\r\nconsole.log(add(5, 10)); // Output: 15\r\nconsole.log(add("5", "10")); // Output: "510" (concatenation instead of addition)\r\nconsole.log(add(5, 10, 15)); // Output: 15 (ignores the third argument)\r\n\r\nfunction greet(name, message) {\r\n  return `Hello, ${name}! ${message}`;\r\n}\r\n\r\n// Example usage\r\nconsole.log(greet("Alice", "How are you?")); // Output: Hello, Alice! How are you?\r\nconsole.log(greet("Bob")); // Output: Hello, Bob! undefined\n'})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",metastring:'title="Default param value"',children:"function myFunction(x, y = 10) {\r\n  return x + y;\r\n}\r\n//Example usage\r\nconsole.log(myFunction(5)); // output: 15\r\nconsole.log(myFunction(5, 11)); // output: 16\n"})}),"\n",(0,a.jsx)(e.h3,{id:"passing-arguments-value-vs-references",children:"Passing Arguments: Value vs References"}),"\n",(0,a.jsxs)(e.p,{children:["In JavaScript, the terms ",(0,a.jsx)(e.code,{children:"arguments"})," and ",(0,a.jsx)(e.code,{children:"parameters"})," are often used interchangeably, but they actually refer to different things:\r\nParameters are the placeholders in the function declaration.\r\nArguments are the actual values passed to the function when it is called."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:'function greet(name, message) {\r\n  // name and message are parameters\r\n  return `Hello, ${name}! ${message}`;\r\n}\r\nconsole.log(greet("Alice", "How are you?")); // "Alice" and "How are you?" are arguments\n'})}),"\n",(0,a.jsx)(e.p,{children:"JavaScript passes arguments by value, meaning the function receives copies of the values, not the original variables."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"function changeValue(value) {\r\n  value = 10; // Changes value only within the function\r\n}\r\n\r\nlet num = 5;\r\nchangeValue(num);\r\nconsole.log(num); // Output: 5 (num remains unchanged)\n"})}),"\n",(0,a.jsx)(e.p,{children:"In JavaScript, object references are values. When you pass an object to a function, you're passing its reference."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:'function changeProperty(obj) {\r\n  obj.name = "Bob"; // Changes property of the object\r\n}\r\n\r\nlet person = { name: "Alice" };\r\nchangeProperty(person);\r\nconsole.log(person.name); // Output: "Bob" (property of the object is changed)\n'})}),"\n",(0,a.jsx)(e.h2,{id:"first-class-and-higher-order-functions",children:"First Class and Higher Order functions"}),"\n",(0,a.jsxs)(e.p,{children:['JavaScript treats functions as simple values as they are another "type" of objects.\r\nHence we can store functions in variables or in properties. This is a ',(0,a.jsx)(e.strong,{children:"concept"})," that is available in different coding languages.\r\nHigher Order function is a function that recieves another function as an argument, that returns a new function or both. Returning function is also called a ",(0,a.jsx)(e.strong,{children:"callback"})]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",metastring:'title="Functions as values"',children:"//Example:1\r\nconst add=(a,b)=>a+b;\r\n//Example:2\r\nconst counter ={\r\n    value:234,\r\n    increment: function(){\r\n        this.value ++1\r\n        }\r\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"We can pass functions as arguments to other functions, return functions from functions and call methods on functions."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",metastring:'title="Versatility of functions"',children:'const greet = () => {\r\n  console.log("Hello, How are you");\r\n  // Higher Order function\r\n  btn.addEventListener("click", greet); //greet is the function that will be called\r\n};\r\n//Function return another function\r\nfunction count() {\r\n  let counter = 0;\r\n  return function () {\r\n    counter++;\r\n  };\r\n}\n'})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",metastring:'title="Callback functions/ Higher order functions"',children:'function manipulateString(str, logString) {\r\n  // Convert the string to uppercase\r\n  const upperCaseStr = str.toUpperCase();\r\n  // Call back with the manipulated string\r\n  logString(upperCaseStr);\r\n}\r\n\r\n// Callback function to log the manipulated string\r\nfunction logManipulatedString(manipulatedStr) {\r\n  console.log("Manipulated String:", manipulatedStr);\r\n}\r\n\r\n// Call the function with callback\r\nmanipulateString("hello world", logManipulatedString); // Output: HELLO WORLD\n'})}),"\n",(0,a.jsx)(e.admonition,{type:"note",children:(0,a.jsx)(e.p,{children:"Function returning a function is possible due to closures."})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",metastring:'title="Function returning another function"',children:'function greet(greeting) {\r\n  // The returned function takes a name and returns a greeting message\r\n  return function (name) {\r\n    return `${greeting}, ${name}!`;\r\n  };\r\n}\r\n\r\n// Usage of the function\r\nconst greetHello = greet("Hello");\r\nconsole.log(greetHello("Alice")); // Output: Hello, Alice!\r\nconsole.log(greetHello("Bob")); // Output: Hello, Bob!\r\n\r\nconst greetGoodbye = greet("Goodbye");\r\nconsole.log(greetGoodbye("Charlie")); // Output: Goodbye, Charlie!\r\nconsole.log(greetGoodbye("David")); // Output: Goodbye, David!\n'})}),"\n",(0,a.jsx)(e.h2,{id:"call-apply-and-bind-methods",children:"Call, Apply and Bind methods"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"call"}),", ",(0,a.jsx)(e.code,{children:"apply"}),", and ",(0,a.jsx)(e.code,{children:"bind"})," are methods in JavaScript used to manipulate the ",(0,a.jsx)(e.code,{children:"this"})," context of functions and to invoke functions with a specific this value. They are often used in object-oriented programming and functional programming paradigms"]}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"call()"})," method calls a function with a given this value and arguments provided individually."]}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"apply()"})," method is similar to ",(0,a.jsx)(e.code,{children:"call()"}),", but it accepts arguments as an array."]}),"\n",(0,a.jsx)(e.admonition,{type:"note",children:(0,a.jsxs)(e.p,{children:["The apply method is not often used in modern JS.",(0,a.jsx)(e.br,{}),"\n","In Modern JS, it is written as ",(0,a.jsx)(e.code,{children:"book.call(thisKeyword, ...Array)"})]})}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"bind()"})," method creates a new function that, when called, has its this value set to a specific value."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",metastring:'title="Call, Apply, Bind method"',children:'const person = {\r\n  fullName: function (city, country) {\r\n    return this.firstName + " " + this.lastName + ", " + city + ", " + country;\r\n  },\r\n};\r\n\r\nconst person1 = {\r\n  firstName: "John",\r\n  lastName: "Doe",\r\n};\r\n\r\nconst person2 = {\r\n  firstName: "Jane",\r\n  lastName: "Doe",\r\n};\r\n\r\n// Using call\r\nconst fullName1 = person.fullName.call(person1, "Oslo", "Norway");\r\nconsole.log(fullName1); // Output: John Doe, Oslo, Norway\r\n\r\nconst fullName2 = person.fullName.call(person2, "Paris", "France");\r\nconsole.log(fullName2); // Output: Jane Doe, Paris, France\r\n\r\n// Using apply\r\nconst fullName3 = person.fullName.apply(person1, ["Oslo", "Norway"]);\r\nconsole.log(fullName3); // Output: John Doe, Oslo, Norway\r\n\r\nconst fullName4 = person.fullName.apply(person2, ["Paris", "France"]);\r\nconsole.log(fullName4); // Output: Jane Doe, Paris, France\r\n\r\n// Using bind\r\nconst fullNameFunc1 = person.fullName.bind(person1);\r\nconsole.log(fullNameFunc1("Oslo", "Norway")); // Output: John Doe, Oslo, Norway\r\n\r\nconst fullNameFunc2 = person.fullName.bind(person2);\r\nconsole.log(fullNameFunc2("Paris", "France")); // Output: Jane Doe, Paris, France\n'})}),"\n",(0,a.jsx)(e.h2,{id:"immediately-invoked-function-expressions-iife",children:"Immediately Invoked Function Expressions (IIFE)"}),"\n",(0,a.jsxs)(e.p,{children:["Immediately Invoked Function Expressions (IIFE) are JavaScript functions that are executed immediately after they are defined. It is a ",(0,a.jsx)(e.strong,{children:"design pattern"})," typically used to create a local scope for variables to prevent them from overriding or polluting the global scope."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",metastring:'title="IIFE"',children:'(function(){\r\n  console.log("Immediately invoked")\r\n})();\r\n(()=>{console.log("Immediately invoked")})();\n'})}),"\n",(0,a.jsx)(e.h2,{id:"closures",children:"Closures"}),"\n",(0,a.jsx)(e.p,{children:"It is a closed-over variable environment of the execution context in which a function was created, even after the execution context is gone. It gives a function access to all the variables of its parent function, even after the parent function has returned. The function keeps a reference of its outer scope, which preserves the scope chain throughout time."}),"\n",(0,a.jsx)(e.admonition,{type:"info",children:(0,a.jsx)(e.p,{children:"Closures are not created manually, it happens automatically in certain situations and we need to identify it."})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",metastring:'title="Closure"',children:"function createCounter() {\r\n  let count = 0;\r\n\r\n  return function() { \r\n    count++; // The inner function has access to the outer function's variables\r\n    return count;\r\n  };\r\n}\r\n\r\nconst counter = createCounter(); \r\n\r\nconsole.log(counter()); // Output: 1\r\nconsole.log(counter()); // Output: 2\r\nconsole.log(counter()); // Output: 3\r\n\r\nconst anotherCounter = createCounter(); // A new instance of the counter\r\nconsole.log(anotherCounter()); // Output: 1\r\nconsole.log(anotherCounter()); // Output: 2\n"})})]})}function d(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(u,{...n})}):u(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>s,x:()=>i});var t=r(6540);const a={},o=t.createContext(a);function s(n){const e=t.useContext(o);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);