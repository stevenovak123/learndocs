"use strict";(self.webpackChunkmy_learnings=self.webpackChunkmy_learnings||[]).push([[726],{7639:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>h,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"DSA/Heap","title":"Heaps","description":"Details about Heaps.","source":"@site/docs/DSA/Heap.md","sourceDirName":"DSA","slug":"/DSA/Heap","permalink":"/learndocs/DSA/Heap","draft":false,"unlisted":false,"editUrl":"https://github.com/stevenovak123/learndocs/tree/master/docs/DSA/Heap.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Heaps","description":"Details about Heaps."},"sidebar":"tutorialSidebar","previous":{"title":"Trees","permalink":"/learndocs/DSA/Tree"},"next":{"title":"Hash Tables/ Maps","permalink":"/learndocs/DSA/HashTable"}}');var t=r(4848),l=r(8453);const a={sidebar_position:5,title:"Heaps",description:"Details about Heaps."},s=void 0,h={},d=[{value:"Max Binary Heap",id:"max-binary-heap",level:2},{value:"Priority Queue",id:"priority-queue",level:2},{value:"Time Complexity",id:"time-complexity",level:2},{value:"Implementation",id:"implementation",level:2}];function o(e){const n={admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Heaps are trees but there are a few properties that make them different.\r\nThere are many types of heaps. Focusing more on binary heaps."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Binary heaps have two children nodes."}),"\n",(0,t.jsxs)(n.li,{children:["There are two types of binary heaps.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Min Binary Heap: Parent always smaller than child nodes."}),"\n",(0,t.jsx)(n.li,{children:"Max Binary Heap: Parent always larger than child nodes."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"max-binary-heap",children:"Max Binary Heap"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Each parent has at most two child nodes."}),"\n",(0,t.jsx)(n.li,{children:"The value of each parent node is always greater than its child nodes."}),"\n",(0,t.jsx)(n.li,{children:"In a max binary heap the parent is greater than the children, but there are no guarantees between sibling nodes."}),"\n",(0,t.jsx)(n.li,{children:"A binary heap is as compact as possible. All the children of each node are as full as they can be and left children are filled out first."}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{title:"Min Binary heaps",type:"tip",children:(0,t.jsx)(n.p,{children:"Min binary heaps are converse of Max binary heaps"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"Binary heaps are used to implement Priority Queue and also used with graph traversal algorithms."})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["Binary heaps implemented using arrays to know each child.\r\nLeft child will be ",(0,t.jsx)(n.strong,{children:"2n+1"})," and Right child will be ",(0,t.jsx)(n.strong,{children:"2n+2"}),".\r\nParent Node will be ",(0,t.jsx)(n.strong,{children:"(n-1)/2"}),". (floored value)"]})}),"\n",(0,t.jsx)(n.h2,{id:"priority-queue",children:"Priority Queue"}),"\n",(0,t.jsx)(n.p,{children:"Priority Queue is a data structure where each element has a priority. Elements with higher priority are served before elements with lower priority."}),"\n",(0,t.jsx)(n.p,{children:"We will implement a min priority queue. (Lower value is higher priority)"}),"\n",(0,t.jsx)(n.h2,{id:"time-complexity",children:"Time Complexity"}),"\n",(0,t.jsx)(n.p,{children:"Time Complexity of insertion and removal are O(log N) and searching is O(N)"}),"\n",(0,t.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"title='Max Binary Heap'",children:"class MaxBinaryHeap {\r\n  constructor() {\r\n    values = [];\r\n  }\r\n  insert(val) {\r\n    this.values.push(val);\r\n    this.bubbleUp();\r\n  }\r\n  bubbleUp() {\r\n    let idx = this.values.length - 1;\r\n    const element = this.values[idx];\r\n    while (idx > 0) {\r\n      let parentIdx = Math.floor((idx - 1) / 2);\r\n      let parent = this.values[parentIdx];\r\n      if (element <= parent) break;\r\n      this.values[parentIdx] = element;\r\n      this.values[idx] = parent;\r\n      idx = parentIdx;\r\n    }\r\n  }\r\n  extractMax() {\r\n    const max = this.values[0];\r\n    const end = this.values.pop();\r\n    if (this.values.length > 0) {\r\n      this.values[0] = end;\r\n      this.bubbleDown();\r\n    }\r\n    return max;\r\n  }\r\n  bubbleDown() {\r\n    let idx = 0;\r\n    const length = this.values.length;\r\n    const element = this.values[0];\r\n    while (true) {\r\n      let leftChildIdx = 2 * idx + 1;\r\n      let rightChildIdx = 2 * idx + 2;\r\n      let leftChild, rightChild;\r\n      let swap = null;\r\n\r\n      if (leftChildIdx < length) {\r\n        leftChild = this.values[leftChildIdx];\r\n        if (leftChild > element) {\r\n          swap = leftChildIdx;\r\n        }\r\n      }\r\n      if (rightChildIdx < length) {\r\n        rightChild = this.values[rightChildIdx];\r\n        if (\r\n          (swap === null && rightChild > element) ||\r\n          (swap !== null && rightChild > leftChild)\r\n        ) {\r\n          swap = rightChildIdx;\r\n        }\r\n      }\r\n      if (swap === null) break;\r\n      this.values[idx] = this.values[swap];\r\n      this.values[swap] = element;\r\n      idx = swap;\r\n    }\r\n  }\r\n}\r\n\r\nlet heap = new MaxBinaryHeap();\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"title='Priority Queue'",children:"class Node {\r\n  constructor(val, priority) {\r\n    this.priority = priority;\r\n    this.val = val;\r\n  }\r\n}\r\nclass PriorityQueue {\r\n  constructor() {\r\n    this.values = [];\r\n  }\r\n  enqueue(val, priority) {\r\n    let newNode = new Node(val, priority);\r\n    this.values.push(newNode);\r\n    this.bubbleUp();\r\n  }\r\n  bubbleUp() {\r\n    let idx = this.values.length - 1;\r\n    const element = this.values[idx];\r\n    while (idx > 0) {\r\n      let parentIdx = Math.floor((idx - 1) / 2);\r\n      let parent = this.values[parentIdx];\r\n      if (element.priority >= parent.priority) break;\r\n      this.values[parentIdx] = element;\r\n      this.values[idx] = parent;\r\n      idx = parentIdx;\r\n    }\r\n  }\r\n  dequeue() {\r\n    const min = this.values[0];\r\n    const end = this.values.pop();\r\n    if (this.values.length > 0) {\r\n      this.values[0] = end;\r\n      this.bubbleDown();\r\n    }\r\n    return min;\r\n  }\r\n  dequeue() {\r\n    let idx = 0;\r\n    const length = this.values.length;\r\n    const element = this.values[0];\r\n    while (true) {\r\n      let leftChildIdx = 2 * idx + 1;\r\n      let rightChildIdx = 2 * idx + 2;\r\n      let leftChild, rightChild;\r\n      let swap = null;\r\n\r\n      if (leftChildIdx < length) {\r\n        leftChild = this.values[leftChildIdx];\r\n        if (leftChild.priority < element.priority) {\r\n          swap = leftChildIdx;\r\n        }\r\n      }\r\n      if (rightChildIdx < length) {\r\n        rightChild = this.values[rightChildIdx];\r\n        if (\r\n          (swap === null && rightChild.priority < element.priority) ||\r\n          (swap !== null && rightChild.priority < leftChild.priority)\r\n        ) {\r\n          swap = rightChildIdx;\r\n        }\r\n      }\r\n      if (swap === null) break;\r\n      this.values[idx] = this.values[swap];\r\n      this.values[swap] = element;\r\n      idx = swap;\r\n    }\r\n  }\r\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>s});var i=r(6540);const t={},l=i.createContext(t);function a(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);