"use strict";(self.webpackChunkmy_learnings=self.webpackChunkmy_learnings||[]).push([[284],{8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(6540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},9641:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"DSA/HashTable","title":"Hash Tables/ Maps","description":"Details about Hash Tables/ Maps.","source":"@site/docs/DSA/HashTable.md","sourceDirName":"DSA","slug":"/DSA/HashTable","permalink":"/learndocs/DSA/HashTable","draft":false,"unlisted":false,"editUrl":"https://github.com/stevenovak123/learndocs/tree/master/docs/DSA/HashTable.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Hash Tables/ Maps","description":"Details about Hash Tables/ Maps."},"sidebar":"tutorialSidebar","previous":{"title":"Heaps","permalink":"/learndocs/DSA/Heap"},"next":{"title":"Graphs","permalink":"/learndocs/DSA/Graphs"}}');var a=t(4848),i=t(8453);const r={sidebar_position:6,title:"Hash Tables/ Maps",description:"Details about Hash Tables/ Maps."},l=void 0,o={},d=[{value:"Time Complexity",id:"time-complexity",level:2},{value:"Implementation",id:"implementation",level:2}];function h(e){const n={admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"It is a default in many programming languages.\r\nIt is used to store in key-value pairs. They are not ordered. It is fast for operations like finding, adding and removing values. the keys used can be string, unlike arrays where the key is a number.\r\nHash tables uses hashing functions."}),"\n",(0,a.jsx)(n.p,{children:"A hashing function is a function that takes a key (usually a string or number) and converts it into an index, a number that tells us where to store the value in an internal array."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"char.charCodeAt(0) - 96"}),"\r\nis commonly used to convert lowercase alphabetic characters ('a' to 'z') into numbers from 1 to 26."]}),"\n",(0,a.jsx)(n.p,{children:'In arrays, we use numbers as indexes directly (like array[0], array[1]). But in hash tables, we want to use custom keys \u2014 like "name", "email", or "age". These are strings, and we can\'t use strings directly as array indexes.'}),"\n",(0,a.jsxs)(n.p,{children:["Sometimes, two different keys might give the same index. This is called a ",(0,a.jsx)(n.strong,{children:"collision"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"To handle this, we can use"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Chaining: Store a list at each index and append values that collide."}),"\n",(0,a.jsx)(n.li,{children:"Open addressing: Find the next available empty slot."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"time-complexity",children:"Time Complexity"}),"\n",(0,a.jsx)(n.p,{children:"In all cases of insertion, deletion and access are O(1). Constant time."}),"\n",(0,a.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"_"})," is used to denote that the function/method is private and not to be used outside of the class."]}),(0,a.jsx)(n.p,{children:"In this implmentation duplicate keys will only show the first key value pair."})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"title='Hash Table implementation'",children:"class HashTable {\r\n  constructor(size = 53) {\r\n    this.keyMap = new Array(size);\r\n  }\r\n  _hash(key) {\r\n    let total = 0;\r\n    let PRIME_NUMBER = 31;\r\n    for (let i = 0; i < Math.min(key.length, 100); i++) {\r\n      const char = key[i];\r\n      let value = char.charCodeAt(0) - 96;\r\n      total = (total * PRIME_NUMBER + value) % this.keyMap.length;\r\n    }\r\n    return total;\r\n  }\r\n  set(key, value) {\r\n    let index = this._hash(key);\r\n    if (!this.keyMap[index]) {\r\n      this.keyMap[index] = [];\r\n    }\r\n    this.keyMap[index].push([key, value]);\r\n  }\r\n  get(key) {\r\n    let index = this._hash(key);\r\n    if (this.keyMap[index]) {\r\n      for (let i = 0; i < this.keyMap[index]; i++) {\r\n        if (this.keyMap[index][i][0] === key) {\r\n          return this.keyMap[index][i][1];\r\n        }\r\n      }\r\n      return this.keyMap[index];\r\n    }\r\n    return undefined;\r\n  }\r\n}\n"})})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}}}]);