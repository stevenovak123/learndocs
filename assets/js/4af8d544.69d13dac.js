"use strict";(self.webpackChunkmy_learnings=self.webpackChunkmy_learnings||[]).push([[385],{8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>a});var t=n(6540);const i={},s=t.createContext(i);function o(e){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:r},e.children)}},8657:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"DSA/Sorting/Merge","title":"Merge Sort","description":"Merge Sort Logic and Code.","source":"@site/docs/DSA/Sorting/Merge.md","sourceDirName":"DSA/Sorting","slug":"/DSA/Sorting/Merge","permalink":"/learndocs/DSA/Sorting/Merge","draft":false,"unlisted":false,"editUrl":"https://github.com/stevenovak123/learndocs/tree/master/docs/DSA/Sorting/Merge.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Merge Sort","description":"Merge Sort Logic and Code."},"sidebar":"tutorialSidebar","previous":{"title":"Insertion Sort","permalink":"/learndocs/DSA/Sorting/Insertion"},"next":{"title":"Quick Sort","permalink":"/learndocs/DSA/Sorting/Quick"}}');var i=n(4848),s=n(8453);const o={sidebar_position:5,title:"Merge Sort",description:"Merge Sort Logic and Code."},a=void 0,l={},c=[{value:"Pseudocode.",id:"pseudocode",level:2},{value:"Time Complexity.",id:"time-complexity",level:2}];function d(e){const r={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.p,{children:"Combination of merging and sorting. Works by decomposing array into smaller arrays of 0 or 1 elements, then building up a newly sorted array."}),"\n",(0,i.jsx)(r.h2,{id:"pseudocode",children:"Pseudocode."}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["In order to merge sort, implement a function responsible for merging two sorted arrays.","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"This function should not modify the params passed to it."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.li,{children:"This helper function, creates a new array, which is sorted and consists of all the elements in the two input arrays."}),"\n",(0,i.jsxs)(r.li,{children:["Create an empty array, take the smallest values in each input array.","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"if the value in the first array is smaller that the value in the second array, push the value in the first array into our results and move to the next value of the first array."}),"\n",(0,i.jsx)(r.li,{children:"if the value of the first array is larger than the second array, push the second array value and move on to the next value in the second array."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"time-complexity",children:"Time Complexity."}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Best, Average and Worst Case is O(n log n)."}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-js",metastring:"title='Merge Sort'",children:"// helper function\r\nfunction merge(arr1, arr2) {\r\n  let results = [];\r\n  let i = 0; //left pointer\r\n  let j = 0; // right pointer\r\n  while (i < arr1.length && j < arr2.length) {\r\n    if (arr2[j] > arr1[i]) {\r\n      results.push(arr1[i]);\r\n      i++;\r\n    } else {\r\n      results.push(arr2[j]);\r\n      j++;\r\n    }\r\n  }\r\n  while (i < arr1.length) {\r\n    results.push(arr1[i]);\r\n    i++;\r\n  }\r\n  while (j < arr2.length) {\r\n    results.push(arr2[j]);\r\n    j++;\r\n  }\r\n  return results;\r\n}\r\n\r\nfunction mergeSort(arr) {\r\n  if (arr.length <= 1) {\r\n    return arr;\r\n  }\r\n  let mid = Math.floor(arr.length / 2);\r\n  let left = mergeSort(arr.slice(0, mid));\r\n  let right = mergeSort(arr.slice(mid));\r\n  return merge(left, right);\r\n}\r\n\r\nlet soln = mergeSort([10, 23, 24, 76, 73, 20, 50]);\r\n\n"})})]})}function u(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);