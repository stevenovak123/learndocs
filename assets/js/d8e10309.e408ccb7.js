"use strict";(self.webpackChunkmy_learnings=self.webpackChunkmy_learnings||[]).push([[519],{8211:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>o,contentTitle:()=>d,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"DSA/LL","title":"Linked List","description":"Details about linked lists.","source":"@site/docs/DSA/LL.md","sourceDirName":"DSA","slug":"/DSA/LL","permalink":"/learndocs/DSA/LL","draft":false,"unlisted":false,"editUrl":"https://github.com/stevenovak123/learndocs/tree/master/docs/DSA/LL.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Linked List","description":"Details about linked lists."},"sidebar":"tutorialSidebar","previous":{"title":"Welcome to DSA","permalink":"/learndocs/DSA/intro"},"next":{"title":"Stacks and Queues","permalink":"/learndocs/DSA/Stack"}}');var i=r(4848),l=r(8453);const s={sidebar_position:2,title:"Linked List",description:"Details about linked lists."},d=void 0,o={},h=[{value:"Properties of Linked lists.",id:"properties-of-linked-lists",level:2},{value:"Code Implementation.",id:"code-implementation",level:2},{value:"Singly Linked List.",id:"singly-linked-list",level:3},{value:"Doubly linked list.",id:"doubly-linked-list",level:3}];function a(n){const e={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.p,{children:"Linked list is a list of data, it consists of nodes. Each node has a value and a pointer. Pointer points to the next node or null."}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Head keeps track of the start of the linked list."}),"\n",(0,i.jsx)(e.li,{children:"Tail keeps track of the end."}),"\n",(0,i.jsx)(e.li,{children:"Length tells the length of the node."}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"There are two types of linked lists."}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Singly linked lists."}),"\n",(0,i.jsx)(e.li,{children:"Doubly linked lists."}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Singly linked means only keeps track of the next node where as doubly means keeps track of the previous node as well."}),"\n",(0,i.jsx)(e.h2,{id:"properties-of-linked-lists",children:"Properties of Linked lists."}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"push - Add a new node."}),"\n",(0,i.jsx)(e.li,{children:"pop - Remove a node."}),"\n",(0,i.jsx)(e.li,{children:"shift - Removing a new node from the beginning of the linked list."}),"\n",(0,i.jsx)(e.li,{children:"unshift - Adding a new node to the beginning of the linked list."}),"\n",(0,i.jsx)(e.li,{children:"get - retrieve the number at that index/position."}),"\n",(0,i.jsx)(e.li,{children:"set - update/change the value of a node based on its position in the linked list."}),"\n",(0,i.jsx)(e.li,{children:"insert - add a new node at a position in the linked list."}),"\n",(0,i.jsx)(e.li,{children:"remove - remove a node from the linked list at a specific position."}),"\n",(0,i.jsx)(e.li,{children:"reverse - reverse a linked list."}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"code-implementation",children:"Code Implementation."}),"\n",(0,i.jsx)(e.h3,{id:"singly-linked-list",children:"Singly Linked List."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",metastring:"title='Singly Linked list'",children:"class Node {\r\n  constructor(val) {\r\n    this.val = val;\r\n    this.next = null;\r\n  }\r\n}\r\nclass SinglyLinkedList {\r\n  constructor() {\r\n    this.length = 0;\r\n    this.head = null;\r\n    this.tail = null;\r\n  }\r\n  push(val) {\r\n    let newNode = new Node(val);\r\n    if (!this.head) {\r\n      this.head = newNode;\r\n      this.tail = this.head;\r\n    } else {\r\n      this.tail.next = newNode;\r\n      this.tail = newNode;\r\n    }\r\n    this.length++;\r\n    return this;\r\n  }\r\n  pop() {\r\n    if (!this.head) {\r\n      return undefined;\r\n    }\r\n    let current = this.head;\r\n    let newTail = current;\r\n    while (current.next) {\r\n      newTail = current;\r\n      current = current.next;\r\n    }\r\n    this.tail = newTail;\r\n    this.tail.next = null;\r\n    this.length--;\r\n    if (this.length === 0) {\r\n      this.head = null;\r\n      this.tail = null;\r\n    }\r\n    return current;\r\n  }\r\n  shift() {\r\n    if (!this.head) {\r\n      return undefined;\r\n    }\r\n    let currentHead = this.head;\r\n    this.head = currentHead.next;\r\n    this.length--;\r\n    if (this.length === 0) {\r\n      this.tail = null;\r\n    }\r\n    return currentHead;\r\n  }\r\n  unshift(val) {\r\n    let newNode = new Node(val);\r\n    if (!this.head) {\r\n      this.head = newNode;\r\n      this.tail = this.head;\r\n    } else {\r\n      newNode.next = this.head;\r\n      this.head = newNode;\r\n    }\r\n    this.length++;\r\n    return this;\r\n  }\r\n  get(index) {\r\n    if (index < 0 || index >= this.length) return null;\r\n    let counter = 0;\r\n    let current = this.head;\r\n    while (counter !== index) {\r\n      current = current.next;\r\n      counter++;\r\n    }\r\n    return current;\r\n  }\r\n  set(index, val) {\r\n    let foundNode = this.get(index);\r\n    if (foundNode) {\r\n      foundNode.val = val;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  insert(index, val) {\r\n    if (index < 0 || index > this.length) return false;\r\n    if (index === this.length) return !!this.push(val); //boolean conversion\r\n    if (index === 0) return !!this.unshift(val); //boolean conversion\r\n    let prev = this.get(index - 1);\r\n    let newNode = new Node(val);\r\n    let temp = prev.next;\r\n    prev.next = newNode;\r\n    newNode.next = temp;\r\n    this.length++;\r\n    return true;\r\n  }\r\n  remove(index) {\r\n    if (index < 0 || index <= this.length) return undefined;\r\n    if (index === 0) return this.shift();\r\n    if (index === this.length - 1) this.pop();\r\n    let prev = this.get(index - 1);\r\n    let removed = prev.next;\r\n    prev.next = removed.next;\r\n    this.length--;\r\n    return removed;\r\n  }\r\n  reverse() {\r\n    let node = this.head;\r\n    this.head = this.tail;\r\n    this.tail = node;\r\n    let prev = null;\r\n    let next = null;\r\n    for (let i = 0; i < this.length; i++) {\r\n      next = node.next;\r\n      node.next = prev;\r\n      prev = node;\r\n      node = next;\r\n    }\r\n    return this;\r\n  }\r\n  // this is created just to view the linked list\r\n  print() {\r\n    let array = [];\r\n    let current = this.head;\r\n    while (current) {\r\n      array.push(current.val);\r\n      current = current.next;\r\n    }\r\n    console.log(array);\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"doubly-linked-list",children:"Doubly linked list."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",metastring:"title='Doubly Linked list'",children:"class Node {\r\n  constructor(val) {\r\n    this.val = val;\r\n    this.next = null;\r\n    this.prev = null;\r\n  }\r\n}\r\nclass DoublyLinkedList {\r\n  constructor() {\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.length = 0;\r\n  }\r\n  push(val) {\r\n    let newNode = new Node(val);\r\n    if (this.length === 0) {\r\n      this.head = newNode;\r\n      this.tail = newNode;\r\n    } else {\r\n      this.tail.next = newNode;\r\n      newNode.prev = this.tail;\r\n      this.tail = newNode;\r\n    }\r\n    this.length++;\r\n    return this;\r\n  }\r\n  pop() {\r\n    if (!this.head) return undefined;\r\n    let removeNode = this.tail;\r\n    if (this.length === 1) {\r\n      this.head = null;\r\n      this.tail = null;\r\n    } else {\r\n      this.tail = removeNode.prev;\r\n      this.tail.next = null;\r\n      removeNode.prev = null;\r\n    }\r\n    this.length--;\r\n    return removeNode;\r\n  }\r\n  shift() {\r\n    if (!this.head) {\r\n      return undefined;\r\n    }\r\n    let oldHead = this.head;\r\n    if (this.length === 1) {\r\n      this.prev = null;\r\n      this.tail = null;\r\n      this.head = null;\r\n    } else {\r\n      this.head = oldHead.next;\r\n      this.head.prev = null;\r\n      oldHead.next = null;\r\n    }\r\n    this.length--;\r\n    return oldHead;\r\n  }\r\n  unshift(val) {\r\n    let newNode = new Node(val);\r\n    if (this.length === 0) {\r\n      this.head = newNode;\r\n      this.tail = newNode;\r\n    } else {\r\n      this.head.prev = newNode;\r\n      newNode.next = this.head;\r\n      this.head = newNode;\r\n    }\r\n    this.length++;\r\n    return this;\r\n  }\r\n  get(index) {\r\n    if (this.length < 0 || index >= this.length) return null;\r\n    let count, current;\r\n    if (index <= this.length / 2) {\r\n      count = 0;\r\n      current = this.head;\r\n      while (count !== index) {\r\n        current = current.next;\r\n        count++;\r\n      }\r\n    } else {\r\n      count = this.length - 1;\r\n      current = this.tail;\r\n      while (count !== index) {\r\n        current = current.prev;\r\n        count--;\r\n      }\r\n    }\r\n    return current;\r\n  }\r\n  set(index, val) {\r\n    let node = this.get(index);\r\n    if (node !== null) {\r\n      node.val = val;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  insert(index, val) {\r\n    if (index < 0 || index > this.length) return false;\r\n    if (index === 0) return this.unshift(val);\r\n    if (index === this.length) return this.push(val);\r\n    let nodeBefore = this.get(index - 1);\r\n    let newNode = new Node(val);\r\n    let nodeAfter = nodeBefore.next;\r\n    nodeBefore.next = newNode;\r\n    newNode.prev = nodeBefore;\r\n    newNode.next = nodeAfter;\r\n    nodeAfter.prev = newNode;\r\n    this.length++;\r\n    return true;\r\n  }\r\n  remove(index) {\r\n    if (index < 0 || index >= this.length) return undefined;\r\n    if (index === 0) return this.shift();\r\n    if (index === this.length - 1) return this.pop();\r\n    let removedNode = this.get(index);\r\n    let prevNode = removedNode.prev;\r\n    let nextNode = removedNode.next;\r\n    prevNode.next = nextNode;\r\n    nextNode.prev = prevNode;\r\n    removedNode.next = null;\r\n    removedNode.prev = null;\r\n    this.length--;\r\n    return removedNode;\r\n  }\r\n}\r\n\n"})})]})}function u(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(a,{...n})}):a(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>s,x:()=>d});var t=r(6540);const i={},l=t.createContext(i);function s(n){const e=t.useContext(l);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function d(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),t.createElement(l.Provider,{value:e},n.children)}}}]);